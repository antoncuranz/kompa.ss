// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: flight.sql

package sqlc

import (
	"context"

	"cloud.google.com/go/civil"
)

const airportExists = `-- name: AirportExists :one
SELECT EXISTS (
    SELECT 1
    FROM airport
    WHERE iata = $1
)
`

func (q *Queries) AirportExists(ctx context.Context, iata string) (bool, error) {
	row := q.db.QueryRow(ctx, airportExists, iata)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getFlightLegsByTransportationID = `-- name: GetFlightLegsByTransportationID :many
SELECT flight_leg.id, flight_leg.transportation_id, flight_leg.origin, flight_leg.destination, flight_leg.airline, flight_leg.flight_number, flight_leg.departure_time, flight_leg.arrival_time, flight_leg.duration_in_minutes, flight_leg.aircraft,
       origin.iata, origin.name, origin.municipality, origin.location_id,
       destination.iata, destination.name, destination.municipality, destination.location_id,
       origin_location.id, origin_location.latitude, origin_location.longitude,
       destination_location.id, destination_location.latitude, destination_location.longitude
FROM flight_leg
         JOIN airport origin on flight_leg.origin = origin.iata
         JOIN airport destination on flight_leg.destination = destination.iata
         JOIN location origin_location on origin.location_id = origin_location.id
         JOIN location destination_location on destination.location_id = destination_location.id
WHERE transportation_id = $1
ORDER BY departure_time
`

type GetFlightLegsByTransportationIDRow struct {
	FlightLeg  FlightLeg
	Airport    Airport
	Airport_2  Airport
	Location   Location
	Location_2 Location
}

func (q *Queries) GetFlightLegsByTransportationID(ctx context.Context, transportationID int32) ([]GetFlightLegsByTransportationIDRow, error) {
	rows, err := q.db.Query(ctx, getFlightLegsByTransportationID, transportationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFlightLegsByTransportationIDRow{}
	for rows.Next() {
		var i GetFlightLegsByTransportationIDRow
		if err := rows.Scan(
			&i.FlightLeg.ID,
			&i.FlightLeg.TransportationID,
			&i.FlightLeg.Origin,
			&i.FlightLeg.Destination,
			&i.FlightLeg.Airline,
			&i.FlightLeg.FlightNumber,
			&i.FlightLeg.DepartureTime,
			&i.FlightLeg.ArrivalTime,
			&i.FlightLeg.DurationInMinutes,
			&i.FlightLeg.Aircraft,
			&i.Airport.Iata,
			&i.Airport.Name,
			&i.Airport.Municipality,
			&i.Airport.LocationID,
			&i.Airport_2.Iata,
			&i.Airport_2.Name,
			&i.Airport_2.Municipality,
			&i.Airport_2.LocationID,
			&i.Location.ID,
			&i.Location.Latitude,
			&i.Location.Longitude,
			&i.Location_2.ID,
			&i.Location_2.Latitude,
			&i.Location_2.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPnrsByTransportationID = `-- name: GetPnrsByTransportationID :many
SELECT id, transportation_id, airline, pnr
FROM flight_pnr
WHERE transportation_id = $1
`

func (q *Queries) GetPnrsByTransportationID(ctx context.Context, transportationID int32) ([]FlightPnr, error) {
	rows, err := q.db.Query(ctx, getPnrsByTransportationID, transportationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlightPnr{}
	for rows.Next() {
		var i FlightPnr
		if err := rows.Scan(
			&i.ID,
			&i.TransportationID,
			&i.Airline,
			&i.Pnr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAirport = `-- name: InsertAirport :exec
INSERT INTO airport (iata, name, municipality, location_id)
VALUES ($1, $2, $3, $4)
`

type InsertAirportParams struct {
	Iata         string
	Name         string
	Municipality string
	LocationID   *int32
}

func (q *Queries) InsertAirport(ctx context.Context, arg InsertAirportParams) error {
	_, err := q.db.Exec(ctx, insertAirport,
		arg.Iata,
		arg.Name,
		arg.Municipality,
		arg.LocationID,
	)
	return err
}

const insertFlightLeg = `-- name: InsertFlightLeg :one
INSERT INTO flight_leg (transportation_id, origin, destination, airline, flight_number, departure_time, arrival_time, duration_in_minutes, aircraft)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id
`

type InsertFlightLegParams struct {
	TransportationID  int32
	Origin            string
	Destination       string
	Airline           string
	FlightNumber      string
	DepartureTime     civil.DateTime
	ArrivalTime       civil.DateTime
	DurationInMinutes int32
	Aircraft          *string
}

func (q *Queries) InsertFlightLeg(ctx context.Context, arg InsertFlightLegParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertFlightLeg,
		arg.TransportationID,
		arg.Origin,
		arg.Destination,
		arg.Airline,
		arg.FlightNumber,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.DurationInMinutes,
		arg.Aircraft,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPNR = `-- name: InsertPNR :one
INSERT INTO flight_pnr (transportation_id, airline, pnr)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertPNRParams struct {
	TransportationID int32
	Airline          string
	Pnr              string
}

func (q *Queries) InsertPNR(ctx context.Context, arg InsertPNRParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertPNR, arg.TransportationID, arg.Airline, arg.Pnr)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateFlightLeg = `-- name: UpdateFlightLeg :exec
UPDATE flight_leg
SET origin              = $2,
    destination         = $3,
    airline             = $4,
    flight_number       = $5,
    departure_time      = $6,
    arrival_time        = $7,
    duration_in_minutes = $8,
    aircraft            = $9
WHERE id = $1
`

type UpdateFlightLegParams struct {
	ID                int32
	Origin            string
	Destination       string
	Airline           string
	FlightNumber      string
	DepartureTime     civil.DateTime
	ArrivalTime       civil.DateTime
	DurationInMinutes int32
	Aircraft          *string
}

func (q *Queries) UpdateFlightLeg(ctx context.Context, arg UpdateFlightLegParams) error {
	_, err := q.db.Exec(ctx, updateFlightLeg,
		arg.ID,
		arg.Origin,
		arg.Destination,
		arg.Airline,
		arg.FlightNumber,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.DurationInMinutes,
		arg.Aircraft,
	)
	return err
}
