// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: train.sql

package sqlc

import (
	"context"

	"cloud.google.com/go/civil"
)

const getTrainDetailByTransportationID = `-- name: GetTrainDetailByTransportationID :one
SELECT transportation_id, refresh_token
FROM train_detail
WHERE transportation_id = $1
`

func (q *Queries) GetTrainDetailByTransportationID(ctx context.Context, transportationID int32) (TrainDetail, error) {
	row := q.db.QueryRow(ctx, getTrainDetailByTransportationID, transportationID)
	var i TrainDetail
	err := row.Scan(&i.TransportationID, &i.RefreshToken)
	return i, err
}

const getTrainLegsByTransportationID = `-- name: GetTrainLegsByTransportationID :many
SELECT train_leg.id, train_leg.transportation_id, train_leg.origin, train_leg.destination, train_leg.departure_time, train_leg.arrival_time, train_leg.line_name, train_leg.duration_in_minutes, train_leg.operator_name,
       origin.id, origin.name, origin.location_id,
       destination.id, destination.name, destination.location_id,
       origin_location.id, origin_location.latitude, origin_location.longitude,
       destination_location.id, destination_location.latitude, destination_location.longitude
FROM train_leg
         JOIN train_station origin on train_leg.origin = origin.id
         JOIN train_station destination on train_leg.destination = destination.id
         JOIN location origin_location on origin.location_id = origin_location.id
         JOIN location destination_location on destination.location_id = destination_location.id
WHERE transportation_id = $1
ORDER BY departure_time
`

type GetTrainLegsByTransportationIDRow struct {
	TrainLeg       TrainLeg
	TrainStation   TrainStation
	TrainStation_2 TrainStation
	Location       Location
	Location_2     Location
}

func (q *Queries) GetTrainLegsByTransportationID(ctx context.Context, transportationID int32) ([]GetTrainLegsByTransportationIDRow, error) {
	rows, err := q.db.Query(ctx, getTrainLegsByTransportationID, transportationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrainLegsByTransportationIDRow{}
	for rows.Next() {
		var i GetTrainLegsByTransportationIDRow
		if err := rows.Scan(
			&i.TrainLeg.ID,
			&i.TrainLeg.TransportationID,
			&i.TrainLeg.Origin,
			&i.TrainLeg.Destination,
			&i.TrainLeg.DepartureTime,
			&i.TrainLeg.ArrivalTime,
			&i.TrainLeg.LineName,
			&i.TrainLeg.DurationInMinutes,
			&i.TrainLeg.OperatorName,
			&i.TrainStation.ID,
			&i.TrainStation.Name,
			&i.TrainStation.LocationID,
			&i.TrainStation_2.ID,
			&i.TrainStation_2.Name,
			&i.TrainStation_2.LocationID,
			&i.Location.ID,
			&i.Location.Latitude,
			&i.Location.Longitude,
			&i.Location_2.ID,
			&i.Location_2.Latitude,
			&i.Location_2.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTrainDetail = `-- name: InsertTrainDetail :exec
INSERT INTO train_detail (transportation_id, refresh_token)
VALUES ($1, $2)
`

type InsertTrainDetailParams struct {
	TransportationID int32
	RefreshToken     string
}

func (q *Queries) InsertTrainDetail(ctx context.Context, arg InsertTrainDetailParams) error {
	_, err := q.db.Exec(ctx, insertTrainDetail, arg.TransportationID, arg.RefreshToken)
	return err
}

const insertTrainLeg = `-- name: InsertTrainLeg :one
INSERT INTO train_leg (transportation_id, origin, destination, departure_time, arrival_time, duration_in_minutes, line_name, operator_name)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type InsertTrainLegParams struct {
	TransportationID  int32
	Origin            string
	Destination       string
	DepartureTime     civil.DateTime
	ArrivalTime       civil.DateTime
	DurationInMinutes int32
	LineName          string
	OperatorName      string
}

func (q *Queries) InsertTrainLeg(ctx context.Context, arg InsertTrainLegParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertTrainLeg,
		arg.TransportationID,
		arg.Origin,
		arg.Destination,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.DurationInMinutes,
		arg.LineName,
		arg.OperatorName,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertTrainStation = `-- name: InsertTrainStation :exec
INSERT INTO train_station (id, name, location_id)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type InsertTrainStationParams struct {
	ID         string
	Name       string
	LocationID *int32
}

func (q *Queries) InsertTrainStation(ctx context.Context, arg InsertTrainStationParams) error {
	_, err := q.db.Exec(ctx, insertTrainStation, arg.ID, arg.Name, arg.LocationID)
	return err
}
